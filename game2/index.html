<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>è¿çº¿ Flow</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#faf7f2;
  font-family:-apple-system,'PingFang SC','Hiragino Sans GB',sans-serif}
#app{width:100%;height:100%;display:flex;flex-direction:column;
  align-items:center;justify-content:space-between;padding:12px 12px env(safe-area-inset-bottom,12px)}
.header{display:flex;justify-content:space-between;align-items:center;width:100%;max-width:480px;padding:8px 4px}
.title{font-size:20px;font-weight:700;color:#6b6260;display:flex;align-items:center;gap:6px}
.title .d{width:8px;height:8px;border-radius:50%;display:inline-block}
.level-badge{background:#fff;border-radius:16px;padding:5px 14px;font-size:13px;color:#a09490;
  font-weight:600;box-shadow:0 2px 6px rgba(0,0,0,.05)}
.info-bar{display:flex;justify-content:center;gap:20px;width:100%;max-width:480px}
.info-item{font-size:12px;color:#b0a8a2;font-weight:500;display:flex;align-items:center;gap:3px}
.info-item span{color:#7a706a;font-weight:700;min-width:24px;text-align:center}
.canvas-wrap{border-radius:18px;background:#fff;box-shadow:0 3px 16px rgba(0,0,0,.06);
  padding:6px;display:flex;align-items:center;justify-content:center}
canvas{display:block;border-radius:13px;touch-action:none}
.pips{display:flex;gap:5px;align-items:center;justify-content:center;flex-wrap:wrap}
.pip{width:24px;height:24px;border-radius:50%;border:2.5px solid #ece7e2;transition:.3s;position:relative}
.pip.done{border-color:currentColor;transform:scale(1.12)}
.pip.done::after{content:'âœ“';position:absolute;inset:0;display:flex;align-items:center;
  justify-content:center;font-size:11px;color:#fff;font-weight:700}
.hint{font-size:12px;color:#c0b8b2;text-align:center;min-height:18px;font-weight:500}
.btns{display:flex;gap:8px}
.btn{height:40px;padding:0 20px;border-radius:20px;border:none;font-size:13px;font-weight:600;
  cursor:pointer;display:flex;align-items:center;gap:4px;transition:.15s;-webkit-tap-highlight-color:transparent}
.btn:active{transform:scale(.95)}
.b2{background:#fff;color:#9a8e88;box-shadow:0 2px 6px rgba(0,0,0,.06)}
.b1{background:linear-gradient(135deg,#a8d8a8,#7cc07c);color:#fff;box-shadow:0 3px 10px rgba(124,192,124,.3)}
.modal-bg{position:fixed;inset:0;background:rgba(250,247,242,.88);backdrop-filter:blur(6px);
  -webkit-backdrop-filter:blur(6px);display:none;align-items:center;justify-content:center;z-index:100}
.modal-bg.show{display:flex}
.modal{background:#fff;border-radius:24px;padding:36px;text-align:center;
  box-shadow:0 8px 36px rgba(0,0,0,.08);max-width:300px;width:88%}
.modal .emo{font-size:44px;margin-bottom:10px}
.modal h2{font-size:22px;color:#5a504a;margin-bottom:4px;font-weight:700}
.modal p{font-size:13px;color:#a09490;margin-bottom:6px;line-height:1.6}
.stars{font-size:26px;margin:10px 0;letter-spacing:3px}
.s1{color:#f0c040}.s0{color:#e0dcd8}
.modal .btn{margin:8px auto 0;width:180px;justify-content:center}
.confetti-wrap{position:fixed;inset:0;pointer-events:none;z-index:99;overflow:hidden}
.cf{position:absolute;border-radius:2px;animation:cfall 1.8s ease-out forwards}
@keyframes cfall{0%{transform:translateY(0) rotate(0) scale(1);opacity:1}
  100%{transform:translateY(500px) rotate(720deg) scale(0);opacity:0}}
</style>
</head>
<body>
<div id="app">
  <div class="header">
    <div class="title">
      <span class="d" style="background:#ef8686"></span>
      <span class="d" style="background:#7cc67c"></span>
      <span class="d" style="background:#6ca6e0"></span>
      è¿çº¿
    </div>
    <div class="level-badge" id="lvlBadge">1 / 20</div>
  </div>
  <div class="info-bar">
    <div class="info-item">æ­¥æ•° <span id="moves">0</span></div>
    <div class="info-item">å®Œæˆ <span id="cover">0/3</span></div>
  </div>
  <div class="canvas-wrap"><canvas id="cv"></canvas></div>
  <div class="pips" id="pips"></div>
  <div class="hint" id="hint">è¿æ¥åŒè‰²ç«¯ç‚¹ï¼›å¸¦å­—æ¯ç«¯ç‚¹éœ€ç»è¿‡æ‰€æœ‰åŒå­—æ¯ç‚¹ï¼Œä¸”ä¸èƒ½ç»è¿‡å…¶ä»–å­—æ¯ç‚¹ ğŸŒ¸</div>
  <div class="btns">
    <button class="btn b2" id="bReset">â†» é‡æ¥</button>
    <button class="btn b2" id="bUndo">â†© æ’¤é”€</button>
    <button class="btn b1" id="bNext">ä¸‹ä¸€å…³ â†’</button>
  </div>
</div>
<div class="modal-bg" id="winM">
  <div class="modal">
    <div class="emo">ğŸ‰</div>
    <h2>å¤ªæ£’äº†ï¼</h2>
    <div class="stars" id="winStars"></div>
    <p id="winMsg"></p>
    <button class="btn b1" id="bWinNext">ä¸‹ä¸€å…³ â†’</button>
  </div>
</div>
<div class="confetti-wrap" id="confWrap"></div>
<script>
const cv=document.getElementById('cv'),cx=cv.getContext('2d');
const COL={red:'#ef8686',green:'#7cc67c',blue:'#6ca6e0',orange:'#efb06c',purple:'#b088d0',
  pink:'#e89ec0',yellow:'#dcc84a',cyan:'#5abcbc'};
const COLD={red:'#c85858',green:'#4e8e4e',blue:'#4878aa',orange:'#b88040',purple:'#7e58a0',
  pink:'#b07090',yellow:'#a89828',cyan:'#3a9090'};
// ====== å…³å¡è®¾è®¡éƒ¨åˆ† ======
const levels=[
  // 1
  {
    grid:5,
    marks:[{x:2,y:3,label:'A'}],
    pairs:[
      {color:'red',points:[[1,1],[3,1]]},
      {color:'blue',points:[{x:1,y:3,need:'A'},{x:3,y:3,need:'A'}]}
    ]
  },
  // 2
  {
    grid:5,
    marks:[{x:2,y:2,label:'A'}],
    pairs:[
      {color:'blue',points:[{x:2,y:0,need:'A'},{x:1,y:2,need:'A'}]},
      {color:'red',points:[{x:3,y:2,need:'A'},{x:2,y:3,need:'A'}]}
    ]
  },
  // 3
  {
    grid:5,
    marks:[{x:1,y:2,label:'A'},{x:3,y:2,label:'A'}],
    pairs:[
      {color:'red',points:[{x:0,y:1,need:'A'},{x:4,y:3,need:'A'}]}
    ]
  },
  // 4
  {
    grid:5,
    marks:[{x:1,y:2,label:'A'},{x:3,y:2,label:'A'}],
    pairs:[
      {color:'blue',points:[{x:1,y:0,need:'A'},{x:3,y:0,need:'A'}]},
      {color:'red',points:[{x:0,y:3,need:'A'},{x:4,y:3,need:'A'}]}
    ]
  },
  // 5
  {
    grid:5,
    marks:[{x:1,y:2,label:'A'},{x:2,y:2,label:'B'},{x:3,y:2,label:'A'}],
    pairs:[
      {color:'blue',points:[{x:0,y:1,need:'A'},{x:4,y:1,need:'A'}]},
      {color:'red',points:[{x:2,y:0,need:'B'},{x:2,y:3,need:'B'}]}
    ]
  }
];
let curLvl=0;

// ====== GAME STATE ======
let gridN=5,cellSz=60,pad=12;
let pairs=[],marks=[],paths={},activeColor=null,drawing=false,won=false,moveN=0;
let undoStack=[];

function calcSizes(){
  const vw=window.innerWidth, vh=window.innerHeight;
  const maxDim=Math.min(vw-40,vh*0.48,480);
  cellSz=Math.floor((maxDim-pad*2)/gridN);
  cellSz=Math.max(32,Math.min(cellSz,72));
  pad=Math.max(8,Math.floor(cellSz*0.2));
}

function resizeCV(){
  calcSizes();
  const s=gridN*cellSz+pad*2;
  const dpr=window.devicePixelRatio||1;
  cv.width=s*dpr; cv.height=s*dpr;
  cv.style.width=s+'px'; cv.style.height=s+'px';
  cx.setTransform(dpr,0,0,dpr,0,0);
  draw();
}

function loadLvl(idx){
  if(idx>=levels.length){
    idx=0;
  }else if(idx<0){
    idx=levels.length-1;
  }
  curLvl=idx;
  const lv=levels[idx];
  gridN=lv.grid;
  pairs=lv.pairs.map(p=>({
    color:p.color,
    points:p.points.map(q=>{
      if(Array.isArray(q)) return {x:q[0],y:q[1],need:null};
      return {x:q.x,y:q.y,need:q.need||q.tag||q.label||null};
    })
  }));
  marks=(lv.marks||[]).map(m=>{
    if(Array.isArray(m)) return {x:m[0],y:m[1],label:String(m[2]||'A')};
    return {x:m.x,y:m.y,label:String(m.label||m.tag||'A')};
  });
  paths={};
  pairs.forEach(p=>paths[p.color]=[]);
  activeColor=null; drawing=false; won=false; moveN=0; undoStack=[];
  document.getElementById('lvlBadge').textContent=`${idx+1} / ${levels.length}`;
  document.getElementById('winM').classList.remove('show');
  buildPips(); resizeCV(); updateUI();
}

function buildPips(){
  const el=document.getElementById('pips'); el.innerHTML='';
  pairs.forEach(p=>{
    const d=document.createElement('div');
    d.className='pip'; d.id='pip_'+p.color;
    d.style.background=COL[p.color]; d.style.color=COLD[p.color];
    el.appendChild(d);
  });
}

// ====== åŠŸèƒ½éƒ¨åˆ†ï¼ˆè§„åˆ™ä¸çŠ¶æ€ï¼‰ ======
function cc(gx,gy){return{x:pad+gx*cellSz+cellSz/2,y:pad+gy*cellSz+cellSz/2}}
function sp(a,b){return a.x===b.x&&a.y===b.y}
function adj(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)===1}
function epColor(gx,gy){for(const p of pairs) for(const pt of p.points) if(pt.x===gx&&pt.y===gy) return p.color; return null}
function markAt(gx,gy){for(const m of marks) if(m.x===gx&&m.y===gy) return m; return null}
function isMarkCell(gx,gy){return !!markAt(gx,gy)}
function getRequiredLabels(color){
  const pr=pairs.find(p=>p.color===color);
  if(!pr) return [];
  const s=new Set();
  for(const pt of pr.points) if(pt.need) s.add(pt.need);
  return [...s];
}
function canEnterMark(color,gx,gy){
  const m=markAt(gx,gy);
  if(!m) return true;
  const req=new Set(getRequiredLabels(color));
  if(req.size===0) return true;
  return req.has(m.label);
}
function pathDone(c){
  const p=paths[c],pr=pairs.find(q=>q.color===c);
  if(!p||p.length<2||!pr) return false;
  const s=p[0],e=p[p.length-1],a=pr.points[0],b=pr.points[1];
  return(sp(s,a)&&sp(e,b))||(sp(s,b)&&sp(e,a));
}
function pathMeetsMarks(color){
  const req=new Set(getRequiredLabels(color));
  if(req.size===0) return true;
  const p=paths[color]||[];
  const hit=new Set(p.map(pt=>pt.x+','+pt.y));
  for(const m of marks){
    const isHit=hit.has(m.x+','+m.y);
    if(req.has(m.label) && !isHit) return false;
    if(!req.has(m.label) && isHit) return false;
  }
  return true;
}
function colorDone(color){
  return pathDone(color)&&pathMeetsMarks(color);
}
function doneCount(){
  let n=0;
  for(const p of pairs) if(colorDone(p.color)) n++;
  return n;
}

// ====== è¡¨ç°éƒ¨åˆ†ï¼ˆç»˜åˆ¶ä¸UIï¼‰ ======
function draw(){
  const w=gridN*cellSz+pad*2;
  cx.clearRect(0,0,w,w);
  // bg
  cx.fillStyle='#faf7f2';
  cx.beginPath(); cx.roundRect(0,0,w,w,13); cx.fill();
  // grid bg
  cx.fillStyle='#f4f0ea';
  cx.beginPath(); cx.roundRect(pad-4,pad-4,gridN*cellSz+8,gridN*cellSz+8,8); cx.fill();

  const dotR=Math.max(4,cellSz*0.08);
  const bigR=Math.max(10,cellSz*0.28);
  const lineW=Math.max(6,cellSz*0.22);

  // grid dots
  for(let gx=0;gx<gridN;gx++) for(let gy=0;gy<gridN;gy++){
    if(epColor(gx,gy)||isMarkCell(gx,gy)) continue;
    const c=cc(gx,gy);
    cx.fillStyle='#d8d2cc'; cx.beginPath(); cx.arc(c.x,c.y,dotR,0,Math.PI*2); cx.fill();
  }

  // letter marks (A/B/...)
  for(const m of marks){
    const c=cc(m.x,m.y);
    cx.fillStyle='rgba(0,0,0,.06)'; cx.beginPath(); cx.arc(c.x+1.5,c.y+1.5,bigR*.92,0,Math.PI*2); cx.fill();
    cx.fillStyle='#f7f3ee'; cx.beginPath(); cx.arc(c.x,c.y,bigR*.92,0,Math.PI*2); cx.fill();
    cx.strokeStyle='#c8c0b8'; cx.lineWidth=2; cx.beginPath(); cx.arc(c.x,c.y,bigR*.92,0,Math.PI*2); cx.stroke();
    cx.fillStyle='#6f6660';
    cx.font=`${Math.max(12,Math.floor(cellSz*0.42))}px sans-serif`;
    cx.textAlign='center'; cx.textBaseline='middle';
    cx.fillText(m.label,c.x,c.y+1);
  }

  // paths
  for(const color in paths){
    const p=paths[color]; if(p.length<2) continue;
    const done=colorDone(color);
    // shadow
    cx.strokeStyle='rgba(0,0,0,.06)'; cx.lineWidth=lineW+4; cx.lineCap='round'; cx.lineJoin='round';
    cx.beginPath();
    let c0=cc(p[0].x,p[0].y); cx.moveTo(c0.x+2,c0.y+2);
    for(let i=1;i<p.length;i++){const c=cc(p[i].x,p[i].y);cx.lineTo(c.x+2,c.y+2)}
    cx.stroke();
    // main
    cx.globalAlpha=done?.75:.5;
    cx.strokeStyle=COL[color]; cx.lineWidth=lineW; cx.beginPath();
    c0=cc(p[0].x,p[0].y); cx.moveTo(c0.x,c0.y);
    for(let i=1;i<p.length;i++){const c=cc(p[i].x,p[i].y);cx.lineTo(c.x,c.y)}
    cx.stroke(); cx.globalAlpha=1;
  }

  // endpoints
  for(const pr of pairs){
    const done=colorDone(pr.color);
    for(const pt of pr.points){
      const c=cc(pt.x,pt.y);
      // ring shadow
      cx.fillStyle='rgba(0,0,0,.08)'; cx.beginPath(); cx.arc(c.x+2,c.y+2,bigR+4,0,Math.PI*2); cx.fill();
      // outer ring
      cx.fillStyle='#888'; cx.beginPath(); cx.arc(c.x,c.y,bigR+4,0,Math.PI*2); cx.fill();
      cx.fillStyle='#666'; cx.beginPath(); cx.arc(c.x,c.y,bigR+1.5,0,Math.PI*2); cx.fill();
      // color fill
      cx.fillStyle=COL[pr.color]; cx.beginPath(); cx.arc(c.x,c.y,bigR-1,0,Math.PI*2); cx.fill();
      if(pt.need){
        cx.fillStyle='rgba(255,255,255,.9)';
        cx.font=`${Math.max(11,Math.floor(cellSz*0.4))}px sans-serif`;
        cx.textAlign='center'; cx.textBaseline='middle';
        cx.fillText(pt.need,c.x,c.y+1);
      }
      // highlight
      const g=cx.createRadialGradient(c.x-bigR*.25,c.y-bigR*.25,1,c.x,c.y,bigR);
      g.addColorStop(0,'rgba(255,255,255,.45)'); g.addColorStop(1,'rgba(255,255,255,0)');
      cx.fillStyle=g; cx.beginPath(); cx.arc(c.x,c.y,bigR-1,0,Math.PI*2); cx.fill();
      // glow if done
      if(done){
        cx.save(); cx.shadowColor=COL[pr.color]; cx.shadowBlur=12;
        cx.fillStyle='transparent'; cx.beginPath(); cx.arc(c.x,c.y,bigR+4,0,Math.PI*2); cx.fill();
        cx.restore();
      }
    }
  }
}

function updateUI(){
  document.getElementById('moves').textContent=moveN;
  const done=doneCount(),total=pairs.length;
  document.getElementById('cover').textContent=`${done}/${total}`;
  const hint=document.getElementById('hint');
  let allDone=true;
  for(const p of pairs){
    const d=colorDone(p.color);
    const pip=document.getElementById('pip_'+p.color);
    if(pip){d?pip.classList.add('done'):pip.classList.remove('done')}
    if(!d) allDone=false;
  }
  if(won) hint.textContent='âœ¨ å®Œç¾é€šå…³ï¼';
  else if(allDone) hint.textContent='âœ¨ å®Œç¾ï¼';
  else hint.textContent='è¿æ¥åŒè‰²ç«¯ç‚¹ï¼›å¸¦å­—æ¯ç«¯ç‚¹éœ€ç»è¿‡æ‰€æœ‰åŒå­—æ¯ç‚¹ï¼Œä¸”ä¸èƒ½ç»è¿‡å…¶ä»–å­—æ¯ç‚¹ ğŸŒ¸';
}

// ====== WIN CHECK ======
function checkWin(){
  for(const p of pairs) if(!colorDone(p.color)) return false;
  return true;
}

function onWin(){
  won=true;
  updateUI();
  // stars based on moves
  const minMoves=gridN*gridN; // theoretical minimum
  let stars=1;
  if(moveN<=minMoves*1.5) stars=3;
  else if(moveN<=minMoves*2.5) stars=2;
  const starsEl=document.getElementById('winStars');
  starsEl.innerHTML='';
  for(let i=0;i<3;i++) starsEl.innerHTML+=`<span class="${i<stars?'s1':'s0'}">â˜…</span>`;
  document.getElementById('winMsg').textContent=`ç”¨äº† ${moveN} æ­¥å®Œæˆï¼`;
  showConfetti();
  setTimeout(()=>document.getElementById('winM').classList.add('show'),600);
}

function showConfetti(){
  const wrap=document.getElementById('confWrap'); wrap.innerHTML='';
  const colors=['#ef8686','#7cc67c','#6ca6e0','#efb06c','#b088d0','#f0c040'];
  for(let i=0;i<40;i++){
    const d=document.createElement('div'); d.className='cf';
    d.style.left=Math.random()*100+'%'; d.style.top='-10px';
    d.style.width=(5+Math.random()*6)+'px'; d.style.height=(5+Math.random()*6)+'px';
    d.style.background=colors[Math.floor(Math.random()*colors.length)];
    d.style.animationDelay=Math.random()*0.6+'s';
    d.style.animationDuration=(1.2+Math.random()*1)+'s';
    wrap.appendChild(d);
  }
  setTimeout(()=>wrap.innerHTML='',3000);
}

// ====== INPUT ======
function getGP(e){
  const r=cv.getBoundingClientRect();
  const sx=cv.width/(window.devicePixelRatio||1)/r.width;
  const sy=cv.height/(window.devicePixelRatio||1)/r.height;
  let px,py;
  if(e.touches){px=(e.touches[0].clientX-r.left)*sx;py=(e.touches[0].clientY-r.top)*sy}
  else{px=(e.clientX-r.left)*sx;py=(e.clientY-r.top)*sy}
  const gx=Math.floor((px-pad)/cellSz), gy=Math.floor((py-pad)/cellSz);
  if(gx<0||gx>=gridN||gy<0||gy>=gridN) return null;
  // check distance to center
  const c=cc(gx,gy);
  if(Math.hypot(px-c.x,py-c.y)>cellSz*0.7) return null;
  return{x:gx,y:gy};
}

function saveUndo(){
  const snap={};
  for(const c in paths) snap[c]=paths[c].map(p=>({...p}));
  undoStack.push(snap);
  if(undoStack.length>200) undoStack.shift();
}

function startDraw(e){
  if(won) return; e.preventDefault();
  const gp=getGP(e); if(!gp) return;

  // Check if clicking on an endpoint
  const ec=epColor(gp.x,gp.y);
  if(ec){
    saveUndo();
    // Check if clicking on the END of an existing path (to extend from there, or start fresh)
    const p=paths[ec];
    if(p.length>0 && sp(p[p.length-1],gp)){
      // Continue from end
      activeColor=ec; drawing=true; draw(); return;
    }
    if(p.length>0 && sp(p[0],gp)){
      // Reverse path and continue from other end... or just restart
      paths[ec]=[{x:gp.x,y:gp.y}];
      activeColor=ec; drawing=true; moveN++; draw(); updateUI(); return;
    }
    // Start new path from this endpoint
    paths[ec]=[{x:gp.x,y:gp.y}];
    activeColor=ec; drawing=true; moveN++; draw(); updateUI(); return;
  }

  // Check if clicking on existing path to truncate and continue
  for(const color in paths){
    const p=paths[color];
    const idx=p.findIndex(pt=>pt.x===gp.x&&pt.y===gp.y);
    if(idx>=0){
      saveUndo();
      // Truncate path at this point and continue
      paths[color]=p.slice(0,idx+1);
      activeColor=color; drawing=true; moveN++; draw(); updateUI(); return;
    }
  }
}

function moveDraw(e){
  if(!drawing||!activeColor||won) return; e.preventDefault();
  const gp=getGP(e); if(!gp) return;
  const p=paths[activeColor]; if(!p.length) return;
  const last=p[p.length-1];
  if(sp(last,gp)) return;

  // Going back? (undo last step in current path)
  if(p.length>=2 && sp(p[p.length-2],gp)){
    p.pop(); draw(); updateUI(); return;
  }

  if(!adj(last,gp)) return;

  // Can't go to endpoint of another color
  const ec=epColor(gp.x,gp.y);
  if(ec && ec!==activeColor) return;

  // If it's our own endpoint, only allow if it's the OTHER endpoint (completing the path)
  if(ec===activeColor){
    const eps=getOwnEndpoints(activeColor);
    const startPt=p[0];
    // The endpoint we're going to should be the one we DIDN'T start from
    const isStart=eps.some(e=>sp(e,gp)&&sp(e,startPt));
    if(isStart && p.length>1) return; // Going back to start, not allowed (use backtrack)
    // It's the other endpoint - allow, this completes the path
  }

  // Can't revisit own path
  if(p.some(pt=>sp(pt,gp))) return;
  if(!canEnterMark(activeColor,gp.x,gp.y)) return;

  // No crossing except on letter cells
  for(const c2 in paths){
    if(c2===activeColor) continue;
    const idx=paths[c2].findIndex(pt=>pt.x===gp.x&&pt.y===gp.y);
    if(idx>=0 && !isMarkCell(gp.x,gp.y)) return;
  }

  p.push({x:gp.x,y:gp.y});

  // If reached other endpoint, STOP drawing (fix issue #1)
  if(colorDone(activeColor)){
    drawing=false; activeColor=null;
    moveN++;
    draw(); updateUI();
    if(checkWin()) onWin();
    return;
  }

  draw(); updateUI();
}

function getOwnEndpoints(color){
  const pr=pairs.find(p=>p.color===color);
  return pr?pr.points:[];
}

function endDraw(e){
  if(drawing) moveN++;
  drawing=false; activeColor=null; updateUI();
}

cv.addEventListener('mousedown',startDraw);
cv.addEventListener('mousemove',moveDraw);
cv.addEventListener('mouseup',endDraw);
cv.addEventListener('mouseleave',endDraw);
cv.addEventListener('touchstart',startDraw,{passive:false});
cv.addEventListener('touchmove',moveDraw,{passive:false});
cv.addEventListener('touchend',endDraw);

// Buttons
document.getElementById('bReset').onclick=()=>loadLvl(curLvl);
document.getElementById('bUndo').onclick=()=>{
  if(won||!undoStack.length) return;
  const snap=undoStack.pop();
  for(const c in snap) paths[c]=snap[c];
  moveN=Math.max(0,moveN-1);
  draw(); updateUI();
};
document.getElementById('bNext').onclick=()=>loadLvl(curLvl+1);
document.getElementById('bWinNext').onclick=()=>loadLvl(curLvl+1);

window.addEventListener('resize',()=>{resizeCV()});

// ====== INIT ======
loadLvl(0);
</script>
</body>
</html>