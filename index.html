<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿çº¿å¯»å® - 3x3 éŸ³æ•ˆç‰ˆ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #FFF0F5; /* æ›´åŠ ç²‰å«©çš„èƒŒæ™¯ */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Fredoka One', cursive;
            touch-action: none;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 60vh;
            max-height: 100vh;
            background: #fff;
            box-shadow: 0 10px 40px rgba(255, 100, 150, 0.15);
            border-radius: 8px;
            overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        #targetBar {
            position: absolute;
            top: 50px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            pointer-events: none;
            z-index: 10;
        }

        .target-icon {
            width: 50px;
            height: 50px;
            background: #F8F8F8;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #DDD;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); /* å¼¹æ€§åŠ¨ç”» */
        }

        .target-icon.active {
            transform: scale(1.3);
            background: #fff;
            box-shadow: 0 5px 20px rgba(255, 138, 128, 0.3);
            border: 3px solid #FF8A80;
            color: #FF8A80;
        }

        .target-icon.done {
            background: #FF8A80;
            color: #fff;
            transform: scale(1);
        }

        #levelIndicator {
            position: absolute;
            bottom: 40px;
            width: 100%;
            text-align: center;
            color: #FFCDD2;
            font-size: 20px;
            letter-spacing: 2px;
        }

        #startHint {
            position: absolute;
            top: 60%;
            width: 100%;
            text-align: center;
            color: #AAA;
            font-size: 18px;
            pointer-events: none;
            animation: float 2s infinite ease-in-out;
        }
        @keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-10px)} }

    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="750" height="1334"></canvas>
    
    <div id="targetBar">
        <div id="icon0" class="target-icon">â­</div>
        <div id="icon1" class="target-icon">ğŸŒ™</div>
        <div id="icon2" class="target-icon">â˜€</div>
    </div>

    <div id="startHint">ç‚¹å‡»å±å¹•å¼€å¯éŸ³æ•ˆå¹¶å¼€å§‹</div>
    <div id="levelIndicator">LEVEL <span id="lvlNum">1</span></div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startHint = document.getElementById('startHint');
    const lvlNumEl = document.getElementById('lvlNum');
    const uiIcons = [
        document.getElementById('icon0'),
        document.getElementById('icon1'),
        document.getElementById('icon2')
    ];

    // ================= éŸ³æ•ˆç®¡ç†å™¨ (Web Audio API) =================
    const AudioSys = {
        ctx: null,
        init: function() {
            if (!this.ctx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            }
            if (this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },
        // æ’­æ”¾å•éŸ³
        playTone: function(freq, type, duration, vol=0.1) {
            if(!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = type; // sine, square, triangle
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        // å‘å°„éŸ³æ•ˆ (å•¾~)
        playShoot: function() {
            if(!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            // é¢‘ç‡ä»é«˜åˆ°ä½æ»‘è½
            osc.frequency.setValueAtTime(600, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
            
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.15);
            
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
        },
        // åƒåˆ°ä¸œè¥¿ (æ ¹æ®é˜¶æ®µæ’­æ”¾ä¸åŒéŸ³æ•ˆ)
        playCollect: function(step) {
            if(!this.ctx) return;
            // step 0: Star, step 1: Moon, step 2: Sun
            
            if (step === 0) {
                // æ˜Ÿæ˜Ÿ: æ¸…è„†çš„ 'Do' (C5)
                this.playTone(523.25, 'sine', 0.3, 0.2);
                setTimeout(() => this.playTone(1046, 'sine', 0.1, 0.05), 50); // æ³›éŸ³
            } else if (step === 1) {
                // æœˆäº®: æŸ”å’Œçš„ 'Mi' (E5)
                this.playTone(659.25, 'sine', 0.4, 0.2);
                setTimeout(() => this.playTone(659.25 * 1.5, 'sine', 0.2, 0.05), 80);
            } else if (step === 2) {
                // å¤ªé˜³: èƒœåˆ©å’Œå¼¦! (C Major Arpeggio)
                const now = this.ctx.currentTime;
                this.playNote(523.25, now, 0.1);       // C5
                this.playNote(659.25, now + 0.08, 0.1); // E5
                this.playNote(783.99, now + 0.16, 0.1); // G5
                this.playNote(1046.5, now + 0.24, 0.4); // C6 (Long)
            }
        },
        playNote: function(freq, time, duration) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.2, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(time);
            osc.stop(time + duration);
        },
        playFail: function() {
            if(!this.ctx) return;
            // ä½æ²‰çš„å™—å™—å£°
            this.playTone(150, 'sawtooth', 0.1, 0.05);
        }
    };

    // ================= é…ç½® =================
    const CONFIG = {
        gridRows: 3,
        gridCols: 3,
        dotRadius: 8,
        playerRadius: 10,
        orbitRadius: 45,
        rotationSpeed: 0.05,
        moveSpeed: 14,
        colors: {
            bg: '#FFFFFF',
            dot: '#EEEEEE',
            player: '#FF8A80',
            trail: '#FFCDD2',
            star: '#FFD54F',
            moon: '#7986CB',
            sun: '#FF7043'
        },
        shapes: ['â­', 'ğŸŒ™', 'â˜€']
    };

    let state = {
        level: 1,
        step: 0,
        dots: [],
        player: null,
        trail: [], 
        targetDotIndex: -1,
        particles: [],
        shake: 0
    };

    // ================= å›¾å½¢ç»˜åˆ¶ (ä¿æŒä¸å˜) =================
    function drawStar(x, y, r, color) {
        ctx.save(); ctx.translate(x, y); ctx.beginPath(); ctx.fillStyle = color;
        for(let i=0; i<5; i++){
            ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*r, -Math.sin((18+i*72)/180*Math.PI)*r);
            ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*(r*0.5), -Math.sin((54+i*72)/180*Math.PI)*(r*0.5));
        }
        ctx.closePath(); ctx.fill(); ctx.restore();
    }
    function drawMoon(x, y, r, color) {
        ctx.save(); ctx.translate(x, y); ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fillStyle = color; ctx.fill();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath(); ctx.arc(r*0.3, -r*0.3, r*0.8, 0, Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over'; ctx.restore();
    }
    function drawSun(x, y, r, color) {
        ctx.save(); ctx.translate(x, y);
        ctx.strokeStyle = color; ctx.lineWidth = 2;
        for(let i=0; i<8; i++) {
            ctx.rotate(Math.PI/4); ctx.beginPath(); ctx.moveTo(r*0.6, 0); ctx.lineTo(r*1.2, 0); ctx.stroke();
        }
        ctx.beginPath(); ctx.arc(0, 0, r*0.6, 0, Math.PI*2); ctx.fillStyle = color; ctx.fill(); ctx.restore();
    }

    // ================= ç²’å­ä¸ç‰¹æ•ˆ =================
    class Particle {
        constructor(x, y, color, speedMulti) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = (Math.random() * 3 + 2) * speedMulti;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
            this.decay = Math.random() * 0.03 + 0.02;
            this.color = color;
            this.size = Math.random() * 5 + 3;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.vy += 0.15; // é‡åŠ›
            this.life -= this.decay;
            this.size *= 0.95;
        }
        draw() {
            ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function spawnParticles(x, y, intensity) {
        let count = 12 * intensity;
        let colors = [];
        if(intensity === 1) colors = [CONFIG.colors.star, '#FFF'];
        if(intensity === 2) colors = [CONFIG.colors.moon, '#E040FB', '#FFF'];
        if(intensity === 3) colors = [CONFIG.colors.sun, '#FF5252', '#FFD740', '#FFFFFF'];

        for(let i=0; i<count; i++) {
            const col = colors[Math.floor(Math.random()*colors.length)];
            state.particles.push(new Particle(x, y, col, 1 + intensity*0.3));
        }
    }

    // ================= æ¸¸æˆé€»è¾‘ =================
    class Dot {
        constructor(x, y, index) {
            this.x = x; this.y = y; this.index = index;
            this.scale = 0; this.targetScale = 1;
        }
        update() {
            if(this.scale < this.targetScale) this.scale += (this.targetScale - this.scale) * 0.15;
        }
        draw() {
            ctx.beginPath(); ctx.arc(this.x, this.y, CONFIG.dotRadius, 0, Math.PI * 2);
            ctx.fillStyle = CONFIG.colors.dot; ctx.fill();
            if (state.targetDotIndex === this.index) {
                const s = this.scale;
                const r = 18 * s;
                const floatY = Math.sin(Date.now() / 200) * 3;
                if (state.step === 0) drawStar(this.x, this.y + floatY, r, CONFIG.colors.star);
                else if (state.step === 1) drawMoon(this.x, this.y + floatY, r, CONFIG.colors.moon);
                else if (state.step === 2) drawSun(this.x, this.y + floatY, r, CONFIG.colors.sun);
            }
        }
    }

    class Player {
        constructor(startDot) {
            this.currentDot = startDot;
            this.angle = -Math.PI / 2;
            this.state = 'rotating';
            this.velocity = {x: 0, y: 0};
            this.updatePos();
        }
        updatePos() {
            this.x = this.currentDot.x + Math.cos(this.angle) * CONFIG.orbitRadius;
            this.y = this.currentDot.y + Math.sin(this.angle) * CONFIG.orbitRadius;
        }
        update() {
            if (this.state === 'rotating') {
                this.angle += CONFIG.rotationSpeed;
                this.updatePos();
            } else if (this.state === 'flying') {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.returnToBase();
                    return;
                }
                for (let dot of state.dots) {
                    if (dot === this.currentDot) continue;
                    const dist = Math.hypot(this.x - dot.x, this.y - dot.y);
                    if (dist < CONFIG.orbitRadius + 5) {
                        this.landOn(dot);
                        return;
                    }
                }
            }
        }
        shoot() {
            if (this.state === 'rotating') {
                // ã€éŸ³æ•ˆã€‘å‘å°„
                AudioSys.playShoot();
                
                this.state = 'flying';
                const angle = Math.atan2(this.y - this.currentDot.y, this.x - this.currentDot.x);
                this.velocity.x = Math.cos(angle) * CONFIG.moveSpeed;
                this.velocity.y = Math.sin(angle) * CONFIG.moveSpeed;
                startHint.style.display = 'none';
            }
        }
        returnToBase() {
            // ã€éŸ³æ•ˆã€‘å¤±è´¥/æ’å¢™
            AudioSys.playFail();
            state.trail = [];
            this.state = 'rotating';
            this.velocity = {x:0, y:0};
            this.updatePos();
            state.shake = 5;
        }
        landOn(newDot) {
            state.trail.push({x1: this.currentDot.x, y1: this.currentDot.y, x2: newDot.x, y2: newDot.y});
            this.state = 'rotating';
            this.currentDot = newDot;
            this.angle = Math.atan2(this.y - newDot.y, this.x - newDot.x);
            if (newDot.index === state.targetDotIndex) {
                this.collectTarget(newDot);
            }
        }
        collectTarget(dot) {
            const step = state.step;
            
            // ã€éŸ³æ•ˆã€‘åƒåˆ°ç›®æ ‡
            AudioSys.playCollect(step);

            spawnParticles(dot.x, dot.y, step + 1);
            state.shake = (step + 1) * 4;
            
            const icon = uiIcons[step];
            icon.classList.remove('active');
            icon.classList.add('done');
            icon.innerText = 'âœ”';

            state.step++;
            if (state.step >= 3) {
                setTimeout(nextLevel, 1200);
            } else {
                spawnNextTarget();
                updateUI();
            }
        }
    }

    // ================= æµç¨‹æ§åˆ¶ =================
    function spawnNextTarget() {
        let candidates = state.dots.filter(d => d !== state.player.currentDot);
        let nextDot = candidates[Math.floor(Math.random() * candidates.length)];
        state.targetDotIndex = nextDot.index;
        nextDot.scale = 0;
    }

    function updateUI() {
        if (state.step < 3) {
            const currIcon = uiIcons[state.step];
            currIcon.classList.add('active');
            currIcon.innerText = CONFIG.shapes[state.step];
        }
    }

    function initLevel() {
        state.step = 0;
        state.trail = [];
        state.dots = [];
        state.particles = [];
        state.targetDotIndex = -1;

        const marginX = 150;
        const marginY = 400;
        const w = canvas.width - marginX * 2;
        const h = canvas.height - marginY * 2;
        const size = Math.min(w, h);
        const step = size / 2;

        let index = 0;
        for(let r=0; r<3; r++){
            for(let c=0; c<3; c++){
                const ox = (canvas.width - size) / 2;
                const oy = (canvas.height - size) / 2 + 50;
                state.dots.push(new Dot(ox + c*step, oy + r*step, index++));
            }
        }

        const startDot = state.dots[6];
        state.player = new Player(startDot);

        uiIcons.forEach((icon, idx) => {
            icon.className = 'target-icon';
            icon.innerText = CONFIG.shapes[idx];
        });
        
        updateUI();
        spawnNextTarget();
    }

    function nextLevel() {
        state.level++;
        lvlNumEl.innerText = state.level;
        initLevel();
    }

    function loop() {
        let sx = 0, sy = 0;
        if (state.shake > 0) {
            sx = (Math.random() - 0.5) * state.shake;
            sy = (Math.random() - 0.5) * state.shake;
            state.shake *= 0.9;
        }

        ctx.setTransform(1, 0, 0, 1, sx, sy);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (state.trail.length > 0) {
            ctx.beginPath();
            for (let l of state.trail) {
                ctx.moveTo(l.x1, l.y1);
                ctx.lineTo(l.x2, l.y2);
            }
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 4;
            ctx.strokeStyle = CONFIG.colors.trail;
            ctx.stroke();
            // å†…æè¾¹
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        state.dots.forEach(d => { d.update(); d.draw(); });

        if (state.player) {
            state.player.update();
            ctx.beginPath();
            ctx.arc(state.player.x, state.player.y, CONFIG.playerRadius, 0, Math.PI*2);
            ctx.fillStyle = CONFIG.colors.player;
            ctx.shadowBlur = 10; ctx.shadowColor = CONFIG.colors.player; ctx.fill(); ctx.shadowBlur = 0;
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(state.player.x-3, state.player.y-3, 3, 0, Math.PI*2); ctx.fill();
        }

        for (let i = state.particles.length - 1; i >= 0; i--) {
            let p = state.particles[i];
            p.update();
            p.draw();
            if (p.life <= 0) state.particles.splice(i, 1);
        }

        requestAnimationFrame(loop);
    }

    // å¤„ç†äº¤äº’ï¼ˆåŒæ—¶åˆå§‹åŒ–éŸ³æ•ˆï¼‰
    function handleInput(e) {
        e.preventDefault();
        AudioSys.init(); // æµè§ˆå™¨è¦æ±‚ç”¨æˆ·äº¤äº’åæ‰èƒ½æ’­æ”¾å£°éŸ³
        state.player.shoot();
    }

    window.addEventListener('mousedown', handleInput);
    window.addEventListener('touchstart', handleInput, {passive: false});

    initLevel();
    loop();

</script>
</body>
</html>