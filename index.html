<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ËøûÁ∫øÂØªÂÆù - ÊúÄÁªàÂÆåÁæéÁâà</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
        
        * { box-sizing: border-box; }

        body {
            margin: 0; padding: 0;
            background-color: #ECEFF1;
            display: flex;
            height: 100vh;
            font-family: 'Fredoka One', cursive;
            color: #333;
            overflow: hidden;
        }

        /* === Â∑¶‰æßÊéßÂà∂Èù¢Êùø === */
        #debugPanel {
            width: 320px;
            background: #263238;
            color: #FFF;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 4px 0 15px rgba(0,0,0,0.3);
            z-index: 100;
            overflow-y: auto;
        }

        #debugPanel h2 { margin: 0 0 10px 0; color: #80CBC4; font-size: 20px; border-bottom: 2px solid #546E7A; padding-bottom: 8px; }
        .control-group { margin-bottom: 4px; }
        .control-group label { display: flex; justify-content: space-between; font-size: 13px; margin-bottom: 4px; color: #B0BEC5; }
        .control-group span { color: #80CBC4; }
        
        input[type="range"], select { width: 100%; padding: 6px; cursor: pointer; }
        input[type="number"] { width: 100%; padding: 8px; background: #37474F; border: none; color: white; border-radius: 4px;}
        
        button {
            background: #00BCD4; color: white; border: none; padding: 12px;
            border-radius: 6px; cursor: pointer; font-weight: bold; margin-top: 10px;
            box-shadow: 0 3px 0 #00838F; transition: 0.1s;
        }
        button:active { transform: translateY(3px); box-shadow: none; }

        /* === Âè≥‰æßÊ∏∏ÊàèÂå∫Âüü === */
        #gameWrapper {
            flex: 1; display: flex; justify-content: center; align-items: center;
            background: #CFD8DC; position: relative;
        }

        #gameContainer {
            position: relative;
            aspect-ratio: 750 / 1334; height: 95vh; max-width: 100%;
            background: #fff; box-shadow: 0 0 60px rgba(0,0,0,0.15);
            border-radius: 10px; overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* UI */
        #levelUI {
            position: absolute; top: 5%; width: 100%;
            display: flex; justify-content: center; gap: 20px; pointer-events: none;
        }
        
        #versusUI {
            position: absolute; top: 5%; width: 100%;
            display: flex; justify-content: space-around; align-items: center;
            pointer-events: none; opacity: 0;
        }
        .score-box { text-align: center; background: rgba(255,255,255,0.9); padding: 5px 15px; border-radius: 15px; }
        .score-val { font-size: 32px; font-weight: bold; }
        .score-label { font-size: 12px; opacity: 0.6; }
        #p1ScoreVal { color: #AB47BC; }
        #aiScoreVal { color: #009688; }
        
        #versusTarget { 
            width: 70px; height: 70px; background: #FFF; 
            border-radius: 50%; display: flex; justify-content: center; align-items: center;
            font-size: 32px; box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            border: 5px solid #FFD54F;
        }

        .target-icon {
            width: 50px; height: 50px; background: #FAFAFA; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: #E0E0E0; border: 2px solid transparent; transition: 0.3s;
        }
        .target-icon.active { transform: scale(1.3); background: #fff; border-color: #AB47BC; color: #AB47BC; }
        .target-icon.done { background: #AB47BC; color: #fff; transform: scale(1); }

        #msgOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.85); backdrop-filter: blur(8px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; display: none; opacity: 0; transition: opacity 0.5s;
        }
        #msgTitle { font-size: 48px; margin-bottom: 20px; color: #333; }
        
    </style>
</head>
<body>

<div id="debugPanel">
    <h2>üõ†Ô∏è Ê∏∏ÊàèÊéßÂà∂Âè∞</h2>
    
    <div class="control-group">
        <label>Ê®°ÂºèÈÄâÊã©</label>
        <select id="optMode">
            <option value="level">ÈóØÂÖ≥Ê®°Âºè (Âçï‰∫∫)</option>
            <option value="versus">ÂØπÊäóÊ®°Âºè (VS AI)</option>
        </select>
    </div>

    <div class="control-group">
        <label>Âú∞ÂõæÂ∞∫ÂØ∏ <span id="valGrid">3x3</span></label>
        <input type="range" id="optGrid" min="3" max="6" step="1" value="3">
    </div>

    <div class="control-group" id="groupAI">
        <label>AI Â§±ËØØÁéá <span id="valAI">10%</span></label>
        <input type="range" id="optAIError" min="0" max="100" step="5" value="10">
        <div style="font-size:11px; color:#78909C; margin-top:2px;">(0=Á•ûÂ∞ÑÊâã, 100=Á∫Ø‰π±Áé©)</div>
    </div>

    <div class="control-group" id="groupTarget">
        <label>ÁõÆÊ†áÊï∞Èáè</label>
        <input type="number" id="optTargetCount" value="3" min="1">
    </div>

    <div class="control-group" id="groupWinScore" style="display:none">
        <label>Ëé∑ËÉúÂàÜÊï∞</label>
        <input type="number" id="optWinScore" value="3" min="1">
    </div>

    <button onclick="applySettings()">Â∫îÁî®ËÆæÁΩÆÂπ∂ÈáçÂºÄ</button>
</div>

<div id="gameWrapper">
    <div id="gameContainer">
        <canvas id="gameCanvas" width="750" height="1334"></canvas>
        <div id="levelUI"></div>
        <div id="versusUI">
            <div class="score-box" style="color: #AB47BC;">
                <div id="p1ScoreVal" class="score-val">0</div>
                <div class="score-label">YOU</div>
            </div>
            <div id="versusTarget">‚≠ê</div>
            <div class="score-box" style="color: #009688;">
                <div id="aiScoreVal" class="score-val">0</div>
                <div class="score-label">AI</div>
            </div>
        </div>
        <div id="msgOverlay">
            <div id="msgTitle">GAME OVER</div>
            <button onclick="applySettings()">ÂÜçÊù•‰∏ÄÂ±Ä</button>
        </div>
    </div>
</div>

<script>
    // ================= 1. ÂàùÂßãÂåñ‰∏éÂ∏∏Èáè =================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Controls
    const optMode = document.getElementById('optMode');
    const optGrid = document.getElementById('optGrid');
    const valGrid = document.getElementById('valGrid');
    const optAIError = document.getElementById('optAIError');
    const valAI = document.getElementById('valAI');
    
    // UI Updates
    optGrid.oninput = () => valGrid.innerText = `${optGrid.value}x${optGrid.value}`;
    optAIError.oninput = () => valAI.innerText = `${optAIError.value}%`;
    optMode.onchange = () => {
        const isVersus = optMode.value === 'versus';
        document.getElementById('groupTarget').style.display = isVersus ? 'none' : 'block';
        document.getElementById('groupWinScore').style.display = isVersus ? 'block' : 'none';
        document.getElementById('groupAI').style.display = isVersus ? 'block' : 'none';
    };

    const COLORS = {
        bg: '#F3E5F5', dot: '#E1BEE7', wall: '#FF7043',
        p1: '#AB47BC', p1Trail: '#CE93D8',
        ai: '#009688', aiTrail: '#80CBC4',
        items: ['#FFD54F', '#7986CB', '#FF5252']
    };
    const SHAPES = ['‚≠ê', 'üåô', '‚òÄ'];

    let CONFIG = {
        grid: 3, mode: 'level', targetCount: 3, winScore: 3,
        orbitR: 45, speed: 16, returnSpeed: 0.2, aiErrorRate: 0.1
    };

    let state = {
        running: false, dots: [], walls: [], entities: [], trail: [], particles: [], shake: 0,
        levelStep: 0, p1Score: 0, aiScore: 0, vsTargetType: 0
    };

    // ================= 2. Èü≥ÊïàÁ≥ªÁªü =================
    const AudioSys = {
        ctx: null,
        init: function() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            if (this.ctx.state === 'suspended') this.ctx.resume();
        },
        play(freq, type, len) {
            if(!this.ctx) return;
            const o = this.ctx.createOscillator(), g = this.ctx.createGain();
            o.type=type; o.frequency.value=freq; 
            g.gain.setValueAtTime(0.1, this.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+len);
            o.connect(g); g.connect(this.ctx.destination);
            o.start(); o.stop(this.ctx.currentTime+len);
        },
        shoot() { this.play(600, 'sine', 0.15); },
        boing() { 
            if(!this.ctx) return;
            const o = this.ctx.createOscillator(), g = this.ctx.createGain();
            o.type='triangle'; 
            o.frequency.setValueAtTime(200, this.ctx.currentTime);
            o.frequency.linearRampToValueAtTime(400, this.ctx.currentTime+0.3);
            g.gain.setValueAtTime(0.2, this.ctx.currentTime);
            g.gain.linearRampToValueAtTime(0, this.ctx.currentTime+0.3);
            o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime+0.3);
        },
        win() { this.play(523, 'square', 0.1); setTimeout(()=>this.play(784,'square',0.2), 100); }
    };

    // ================= 3. Á±ªÂÆö‰πâ =================
    class Dot {
        constructor(x, y, r, c, idx) {
            this.x = x; this.y = y; this.r = r; this.c = c; this.index = idx;
            this.item = -1; this.scale = 0; this.targetScale = 0;
        }
        update() { this.scale += (this.targetScale - this.scale) * 0.2; }
        draw() {
            ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fillStyle = COLORS.dot; ctx.fill();
            if(this.scale > 0.01 && this.item !== -1) drawItem(this.x, this.y, this.item, this.scale);
        }
    }

    class Wall {
        constructor(dA, dB) { this.x1=dA.x; this.y1=dA.y; this.x2=dB.x; this.y2=dB.y; }
        draw() {
            ctx.beginPath(); ctx.moveTo(this.x1,this.y1); ctx.lineTo(this.x2,this.y2);
            ctx.lineWidth=8; ctx.strokeStyle=COLORS.wall; ctx.lineCap='round'; ctx.stroke();
            ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.4)'; ctx.stroke();
        }
    }

    class Entity {
        constructor(isAI, startDot) {
            this.isAI = isAI;
            this.color = isAI ? COLORS.ai : COLORS.p1;
            this.curDot = startDot;
            this.angle = -Math.PI/2;
            this.pos = {x: startDot.x, y: startDot.y - CONFIG.orbitR};
            this.state = 'rotating'; 
            this.velocity = {x:0, y:0};
            
            this.aiTimer = 0;
            this.lastDot = null;
        }
        update() {
            if(this.state === 'rotating') {
                this.angle += 0.05;
                this.pos.x = this.curDot.x + Math.cos(this.angle) * CONFIG.orbitR;
                this.pos.y = this.curDot.y + Math.sin(this.angle) * CONFIG.orbitR;
                if(this.isAI) this.aiThink();
            } else if(this.state === 'flying') {
                const px = this.pos.x, py = this.pos.y;
                this.pos.x += this.velocity.x; this.pos.y += this.velocity.y;

                if(checkWall(px, py, this.pos.x, this.pos.y) || 
                   this.pos.x<0 || this.pos.x>canvas.width || this.pos.y<0 || this.pos.y>canvas.height) {
                    this.triggerReturn();
                    return;
                }
                for(let d of state.dots) {
                    if(d === this.curDot) continue;
                    if(Math.hypot(this.pos.x-d.x, this.pos.y-d.y) < CONFIG.orbitR + 5) {
                        this.land(d);
                        return;
                    }
                }
            } else if(this.state === 'returning') {
                const tx = this.curDot.x, ty = this.curDot.y;
                this.pos.x += (tx - this.pos.x) * CONFIG.returnSpeed;
                this.pos.y += (ty - this.pos.y) * CONFIG.returnSpeed;
                if(Math.hypot(this.pos.x-tx, this.pos.y-ty) < 10) {
                    this.state = 'rotating';
                    this.angle = Math.atan2(this.pos.y-ty, this.pos.x-tx);
                }
            }
        }
        shoot() {
            if(this.state !== 'rotating') return;
            AudioSys.shoot();
            this.state = 'flying';
            const a = Math.atan2(this.pos.y - this.curDot.y, this.pos.x - this.curDot.x);
            this.velocity = { x: Math.cos(a)*CONFIG.speed, y: Math.sin(a)*CONFIG.speed };
        }
        triggerReturn() {
            AudioSys.boing();
            spawnParticles(this.pos.x, this.pos.y, COLORS.wall);
            state.shake = 5;
            this.state = 'returning';
        }
        land(dot) {
            state.trail.push({x1:this.curDot.x, y1:this.curDot.y, x2:dot.x, y2:dot.y, c: this.isAI?COLORS.aiTrail:COLORS.p1Trail});
            if(state.trail.length>10) state.trail.shift();

            this.lastDot = this.curDot; // ËÆ∞ÂΩïÂéÜÂè≤
            this.state = 'rotating';
            this.curDot = dot;
            this.angle = Math.atan2(this.pos.y-dot.y, this.pos.x-dot.x);
            checkLogic(this, dot);
        }
        draw() {
            if(this.state === 'flying' || this.state === 'returning') {
                ctx.beginPath(); ctx.moveTo(this.curDot.x, this.curDot.y); ctx.lineTo(this.pos.x, this.pos.y);
                ctx.strokeStyle = this.color; ctx.lineWidth=2; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
            }
            ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI*2); ctx.fillStyle = this.color; ctx.fill();
            ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(this.pos.x-3, this.pos.y-3, 3, 0, Math.PI*2); ctx.fill();
            if(this.isAI) { ctx.fillStyle='#fff'; ctx.font='bold 10px Arial'; ctx.fillText('AI', this.pos.x-5, this.pos.y+4); }
        }
        
        // --- AI ÈÄªËæë ---
        aiThink() {
            const now = Date.now();
            if(now < this.aiTimer) return;
            
            let target = null;
            if(CONFIG.mode === 'versus') {
                let targets = state.dots.filter(d => d.item === state.vsTargetType);
                if(targets.length > 0) {
                    targets.sort((a,b) => dist(this.curDot, a) - dist(this.curDot, b));
                    target = targets[0];
                }
            }
            if(!target) return;

            // 1. ÂØªÊâæÁõ¥Á∫øÈÇªÂ±Ö
            // „ÄêÂÖ≥ÈîÆ‰øÆÊîπ„Äë‰∏çÂÜçÊ£ÄÊü• checkWallÔºåÂõ†‰∏∫ÊñúÂêëÂ¢ôÂπ∂‰∏çÈòªÊå°Áõ¥Á∫øÁßªÂä®
            const neighbors = state.dots.filter(d => 
                (Math.abs(d.r - this.curDot.r) + Math.abs(d.c - this.curDot.c) === 1)
            );
            
            let candidates = neighbors;
            if(neighbors.length > 1 && this.lastDot) {
                candidates = neighbors.filter(n => n !== this.lastDot);
            }

            let bestNext = null;
            let minD = Infinity;
            for(let n of candidates) {
                let d = dist(n, target);
                if(d < minD) { minD = d; bestNext = n; }
            }

            if(bestNext) {
                let aimAngle = Math.atan2(bestNext.y - this.curDot.y, bestNext.x - this.curDot.x);
                let curAngle = normalizeAngle(this.angle);
                let tarAngle = normalizeAngle(aimAngle);

                const willFail = Math.random() < CONFIG.aiErrorRate;
                
                if(willFail) {
                    // Ê®°ÊãüÂ§±ËØØÔºöÂú®Ê≤°ÂØπÂáÜÊó∂Â∞±Â∞ÑÂáªÔºåÊàñËÄÖÊïÖÊÑèÂÅèÁßª
                    const diff = Math.abs(curAngle - tarAngle);
                    if((diff < 1.0 && diff > 0.3) && Math.random() < 0.1) {
                        this.shoot();
                        this.aiTimer = now + 1000;
                    }
                } else {
                    // Á≤æÂáÜÂ∞ÑÂáª
                    const diff = Math.abs(curAngle - tarAngle);
                    if(diff < 0.1 || Math.abs(diff - Math.PI*2) < 0.1) {
                        this.shoot();
                    }
                }
            }
        }
    }

    // ================= 4. ËæÖÂä©ÂáΩÊï∞ =================
    function dist(a, b) { return Math.hypot(a.x-b.x, a.y-b.y); }
    function normalizeAngle(a) { let r = a % (Math.PI*2); return r < 0 ? r + Math.PI*2 : r; }
    
    // „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç„ÄëÁ¢∞ÊíûÊ£ÄÊµãÔºöÊéíÈô§Á´ØÁÇπÊé•Ëß¶ÔºåÂè™ÊúâÁúüÊ≠£Á©øËøáÊâçÁÆóÊíûÂ¢ô
    // ÊñúÂêëÂ¢ôÂ£Å‰∏çÈòªÊå°Áõ¥Á∫øÁßªÂä®ÔºåÂõ†‰∏∫Áõ¥Á∫øÁßªÂä®ÁöÑ‰∏≠ÁÇπ‰∏ç‰ºöËêΩÂú®ÊñúÁ∫ø‰∏ä
    function checkWall(x1, y1, x2, y2) {
        for(let w of state.walls) {
            let d = (w.y2-w.y1)*(x2-x1) - (w.x2-w.x1)*(y2-y1);
            if(d === 0) continue;
            let ua = ((w.x2-w.x1)*(y1-w.y1) - (w.y2-w.y1)*(x1-w.x1)) / d;
            let ub = ((x2-x1)*(y1-w.y1) - (y2-y1)*(x1-w.x1)) / d;
            // Êîπ‰∏∫‰∏•Ê†ºÂ§ß‰∫é0ÂíåÂ∞è‰∫é1ÔºåÊéíÈô§Á´ØÁÇπÈáçÂêàÁöÑÊÉÖÂÜµ
            if(ua > 0.05 && ua < 0.95 && ub > 0.05 && ub < 0.95) return true;
        }
        return false;
    }

    function spawnParticles(x, y, c) {
        for(let i=0;i<8;i++) state.particles.push({x, y, vx:(Math.random()-.5)*10, vy:(Math.random()-.5)*10, life:1, c});
    }
    
    function drawItem(x, y, type, s) {
        ctx.save(); ctx.translate(x, y + Math.sin(Date.now()/200)*2);
        if(type===0) {
            ctx.beginPath(); ctx.fillStyle=COLORS.items[0];
            for(let i=0;i<5;i++){ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*18*s,-Math.sin((18+i*72)/180*Math.PI)*18*s);ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*9*s,-Math.sin((54+i*72)/180*Math.PI)*9*s);}
            ctx.fill();
        } else if(type===1) {
            let r=16*s; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fillStyle=COLORS.items[1]; ctx.fill();
            ctx.globalCompositeOperation='destination-out'; ctx.beginPath(); ctx.arc(r*0.4,-r*0.4,r*0.9,0,Math.PI*2); ctx.fill();
        } else {
            let r=18*s; ctx.strokeStyle=COLORS.items[2]; ctx.lineWidth=2;
            for(let i=0;i<8;i++){ctx.rotate(Math.PI/4);ctx.beginPath();ctx.moveTo(r*0.5,0);ctx.lineTo(r,0);ctx.stroke();}
            ctx.beginPath();ctx.arc(0,0,r*0.5,0,Math.PI*2);ctx.fillStyle=COLORS.items[2];ctx.fill();
        }
        ctx.restore();
    }

    // ================= 5. Ê∏∏ÊàèÊµÅÁ®ã =================
    function applySettings() {
        CONFIG.mode = optMode.value;
        CONFIG.grid = parseInt(optGrid.value);
        CONFIG.targetCount = parseInt(document.getElementById('optTargetCount').value);
        CONFIG.winScore = parseInt(document.getElementById('optWinScore').value);
        CONFIG.aiErrorRate = parseInt(optAIError.value) / 100;

        state = { running: true, dots: [], walls: [], entities: [], trail: [], particles: [], shake: 0, levelStep: 0, p1Score: 0, aiScore: 0, vsTargetType: 0 };
        document.getElementById('msgOverlay').style.opacity = 0;
        setTimeout(()=>document.getElementById('msgOverlay').style.display='none', 500);

        // ÁîüÊàêÂú∞Âõæ
        const padX = 80, padY = 200;
        const size = Math.min(canvas.width - padX, canvas.height - padY);
        const step = size / (CONFIG.grid - 1);
        const startX = (canvas.width - size)/2;
        const startY = (canvas.height - size)/2 + 50;
        let idx = 0;
        for(let r=0; r<CONFIG.grid; r++) for(let c=0; c<CONFIG.grid; c++) state.dots.push(new Dot(startX + c*step, startY + r*step, r, c, idx++));

        // ÁîüÊàêÊñúÂ¢ô (Level 2 Êï∞Èáè)
        let nWalls = Math.floor(CONFIG.grid * 0.8);
        for(let i=0; i<nWalls; i++) {
            let a = state.dots[Math.floor(Math.random()*state.dots.length)];
            let b = state.dots.find(d => Math.abs(d.r-a.r)===1 && Math.abs(d.c-a.c)===1);
            if(b && !state.walls.some(w => (w.x1===a.x && w.x2===b.x))) state.walls.push(new Wall(a, b));
        }

        // ÁîüÊàêÁé©ÂÆ∂
        state.entities.push(new Entity(false, state.dots[state.dots.length - CONFIG.grid]));

        if(CONFIG.mode === 'versus') {
            state.entities.push(new Entity(true, state.dots[CONFIG.grid - 1]));
            document.getElementById('levelUI').style.opacity = 0;
            document.getElementById('versusUI').style.opacity = 1;
            document.getElementById('p1ScoreVal').innerText = 0;
            document.getElementById('aiScoreVal').innerText = 0;
            spawnVersusItems();
        } else {
            document.getElementById('levelUI').style.opacity = 1;
            document.getElementById('versusUI').style.opacity = 0;
            initLevelUI(); spawnLevelTarget();
        }
    }

    function spawnVersusItems() {
        state.dots.forEach(d => {d.item=-1; d.targetScale=0;});
        state.vsTargetType = Math.floor(Math.random()*3);
        document.getElementById('versusTarget').innerText = SHAPES[state.vsTargetType];

        const occupied = state.entities.map(e => e.curDot);
        let safeDots = state.dots.filter(d => !occupied.includes(d));
        if (safeDots.length === 0) return;

        let count = Math.max(1, Math.ceil(state.dots.length / 3));
        let assigned = 0;
        let tDot = safeDots[Math.floor(Math.random()*safeDots.length)];
        tDot.item = state.vsTargetType; tDot.targetScale = 1;
        assigned++;

        while(assigned < count) {
            let d = safeDots[Math.floor(Math.random()*safeDots.length)];
            if(d.item === -1) {
                d.item = Math.floor(Math.random()*3); d.targetScale = 1;
                assigned++;
            }
        }
    }

    // ÈóØÂÖ≥ÁâπÊúâ
    function initLevelUI() {
        const ui = document.getElementById('levelUI'); ui.innerHTML = '';
        for(let i=0; i<CONFIG.targetCount; i++) {
            let el = document.createElement('div'); el.className = 'target-icon'; el.innerText = SHAPES[i%3];
            ui.appendChild(el);
        }
        updateLevelUI();
    }
    function updateLevelUI() {
        const ui = document.getElementById('levelUI');
        for(let i=0; i<ui.children.length; i++) {
            ui.children[i].classList.toggle('active', i === state.levelStep);
        }
    }
    function spawnLevelTarget() {
        let safe = state.dots.filter(d => d !== state.entities[0].curDot);
        let t = safe[Math.floor(Math.random()*safe.length)];
        t.item = state.levelStep % 3; t.targetScale = 1;
    }

    function checkLogic(entity, dot) {
        let hit = false;
        if(CONFIG.mode === 'level') {
            if(!entity.isAI && dot.item === state.levelStep % 3) {
                hit = true; state.levelStep++;
                document.getElementById('levelUI').children[state.levelStep-1].classList.add('done');
                if(state.levelStep >= CONFIG.targetCount) endGame('ÈóØÂÖ≥ÊàêÂäü!');
                else { spawnLevelTarget(); updateLevelUI(); }
            }
        } else {
            if(dot.item === state.vsTargetType) {
                hit = true;
                if(entity.isAI) { state.aiScore++; document.getElementById('aiScoreVal').innerText=state.aiScore; }
                else { state.p1Score++; document.getElementById('p1ScoreVal').innerText=state.p1Score; }
                if(state.p1Score >= CONFIG.winScore) endGame('‰Ω†Ëµ¢‰∫Ü!');
                else if(state.aiScore >= CONFIG.winScore) endGame('AI Ëµ¢‰∫Ü!');
                else spawnVersusItems();
            }
        }
        if(hit) {
            AudioSys.win(); spawnParticles(dot.x, dot.y, COLORS.items[0]); state.shake = 10;
            dot.item = -1; dot.targetScale = 0;
        } else if(dot.item !== -1) {
            entity.triggerReturn();
        }
    }

    function endGame(msg) {
        state.running = false;
        document.getElementById('msgTitle').innerText = msg;
        document.getElementById('msgOverlay').style.display = 'flex';
        setTimeout(()=>document.getElementById('msgOverlay').style.opacity = 1, 10);
    }

    function loop() {
        requestAnimationFrame(loop);
        let sx=0, sy=0;
        if(state.shake>0) { sx=(Math.random()-.5)*state.shake; sy=(Math.random()-.5)*state.shake; state.shake*=0.9; }
        ctx.setTransform(1,0,0,1,sx,sy); ctx.clearRect(0,0,canvas.width,canvas.height);

        state.walls.forEach(w => w.draw());
        state.trail.forEach(t => {
            ctx.beginPath(); ctx.moveTo(t.x1,t.y1); ctx.lineTo(t.x2,t.y2);
            ctx.strokeStyle=t.c; ctx.lineWidth=4; ctx.stroke();
        });
        state.dots.forEach(d => { d.update(); d.draw(); });
        state.entities.forEach(e => { e.update(); e.draw(); });
        
        for(let i=state.particles.length-1; i>=0; i--) {
            let p = state.particles[i];
            p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
            ctx.globalAlpha=p.life; ctx.fillStyle=p.c; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2); ctx.fill();
            if(p.life<=0) state.particles.splice(i,1);
        }
        ctx.globalAlpha=1;
    }

    function input(e) {
        if(e.target.tagName !== 'CANVAS') return;
        e.preventDefault(); AudioSys.init();
        if(state.running && state.entities[0]) state.entities[0].shoot();
    }
    window.addEventListener('mousedown', input); window.addEventListener('touchstart', input, {passive:false});

    applySettings();
    loop();

</script>
</body>
</html>