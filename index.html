<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿çº¿å¯»å® - æºœæºœçƒä¸æ–œå¢™</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        body {
            margin: 0; padding: 0;
            background-color: #F3E5F5; /* æ·¡ç´«è‰²èƒŒæ™¯ */
            display: flex; justify-content: center; align-items: center;
            height: 100vh; overflow: hidden;
            font-family: 'Fredoka One', cursive;
            touch-action: none; user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100%; height: 100%;
            max-width: 60vh; max-height: 100vh;
            background: #fff;
            box-shadow: 0 10px 40px rgba(150, 100, 200, 0.15);
            border-radius: 12px; overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; }

        #targetBar {
            position: absolute; top: 60px; width: 100%;
            display: flex; justify-content: center; align-items: center;
            gap: 20px; pointer-events: none; z-index: 10;
        }

        .target-icon {
            width: 50px; height: 50px;
            background: #FAFAFA; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: #E0E0E0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .target-icon.active {
            transform: scale(1.3); background: #fff;
            border: 3px solid #AB47BC; color: #AB47BC;
            box-shadow: 0 5px 20px rgba(171, 71, 188, 0.3);
        }
        .target-icon.done {
            background: #AB47BC; color: #fff; transform: scale(1);
        }

        #levelIndicator {
            position: absolute; bottom: 50px; width: 100%;
            text-align: center; color: #CE93D8;
            font-size: 24px; letter-spacing: 2px;
        }
        
        #hint {
            position: absolute; bottom: 120px; width: 100%;
            text-align: center; color: #BA68C8; font-size: 16px;
            opacity: 0.8; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="750" height="1334"></canvas>
    
    <div id="targetBar">
        <div id="icon0" class="target-icon">â­</div>
        <div id="icon1" class="target-icon">ğŸŒ™</div>
        <div id="icon2" class="target-icon">â˜€</div>
    </div>

    <div id="hint">å°å¿ƒæ–œå‘çš„éšœç¢å¢™ï¼</div>
    <div id="levelIndicator">LEVEL <span id="lvlNum">1</span></div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const lvlNumEl = document.getElementById('lvlNum');
    const uiIcons = [document.getElementById('icon0'), document.getElementById('icon1'), document.getElementById('icon2')];

    // ================= éŸ³æ•ˆç³»ç»Ÿ =================
    const AudioSys = {
        ctx: null,
        init: function() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            if (this.ctx.state === 'suspended') this.ctx.resume();
        },
        playTone: function(freq, type, dur, vol=0.1) {
            if(!this.ctx) return;
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.type = type; osc.frequency.value = freq;
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + dur);
        },
        // æºœæºœçƒå¼¹å›éŸ³æ•ˆ (Boing~)
        playBoing: function() {
            if(!this.ctx) return;
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.type = 'sine';
            // é¢‘ç‡å…ˆé™åå‡ï¼Œæ¨¡æ‹Ÿå¼¹ç°§
            osc.frequency.setValueAtTime(300, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(150, this.ctx.currentTime + 0.1);
            osc.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 0.3);
            
            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
            
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + 0.3);
        },
        playShoot: function() {
            if(!this.ctx) return;
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(600, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.15);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + 0.15);
        },
        playCollect: function(step) {
            if(step===0) { this.playTone(523, 'sine', 0.3); setTimeout(()=>this.playTone(1046,'sine',0.1),50); }
            else if(step===1) { this.playTone(659, 'sine', 0.4); setTimeout(()=>this.playTone(987,'sine',0.2),80); }
            else { 
                const t = this.ctx.currentTime;
                this.playTone(523, 'sine', 0.1); setTimeout(()=>this.playTone(659,'sine',0.1),80);
                setTimeout(()=>this.playTone(783,'sine',0.1),160); setTimeout(()=>this.playTone(1046,'sine',0.4),240);
            }
        }
    };

    // ================= é…ç½® =================
    const CONFIG = {
        gridSize: 3,
        orbitRadius: 40,
        rotationSpeed: 0.05,
        moveSpeed: 16,
        returnSpeed: 0.15, // æºœæºœçƒæ”¶å›çš„é€Ÿåº¦ç³»æ•° (Lerp)
        colors: {
            bg: '#F3E5F5',
            dot: '#E1BEE7',
            player: '#AB47BC', // ç´«è‰²ç³»
            trail: '#E1BEE7',  // æˆåŠŸçš„è¿çº¿
            yoyoString: '#BA68C8', // æºœæºœçƒçš„ç»³å­
            wall: '#FF7043',   // æ©™è‰²éšœç¢å¢™ï¼Œå¯¹æ¯”æ˜æ˜¾
            star: '#FFD54F', moon: '#7986CB', sun: '#FF7043'
        },
        shapes: ['â­', 'ğŸŒ™', 'â˜€']
    };

    let state = {
        level: 1, step: 0, dots: [], walls: [], 
        player: null, trail: [], targetDotIndex: -1, particles: [], shake: 0
    };

    class Dot {
        constructor(x, y, r, c, idx) {
            this.x = x; this.y = y; this.r = r; this.c = c; this.index = idx;
            this.scale = 0; this.targetScale = 1;
        }
        update() { if(this.scale < this.targetScale) this.scale += (this.targetScale-this.scale)*0.15; }
        draw() {
            ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2);
            ctx.fillStyle = CONFIG.colors.dot; ctx.fill();
            if(state.targetDotIndex === this.index) {
                const s = this.scale;
                const floatY = Math.sin(Date.now()/200)*3;
                drawIcon(this.x, this.y+floatY, 18*s, state.step);
            }
        }
    }

    class Wall {
        constructor(dotA, dotB) {
            this.x1 = dotA.x; this.y1 = dotA.y;
            this.x2 = dotB.x; this.y2 = dotB.y;
        }
        draw() {
            ctx.beginPath();
            ctx.moveTo(this.x1, this.y1);
            ctx.lineTo(this.x2, this.y2);
            ctx.lineWidth = 6;
            ctx.strokeStyle = CONFIG.colors.wall;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            // ç»˜åˆ¶æ–œçº¿çº¹ç†
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.stroke();
        }
    }

    class Player {
        constructor(startDot) {
            this.currentDot = startDot;
            this.angle = -Math.PI/2;
            this.state = 'rotating'; // rotating, flying, returning
            this.pos = {x:0, y:0};
            this.updatePos();
        }
        updatePos() {
            this.pos.x = this.currentDot.x + Math.cos(this.angle) * CONFIG.orbitRadius;
            this.pos.y = this.currentDot.y + Math.sin(this.angle) * CONFIG.orbitRadius;
        }
        update() {
            if(this.state === 'rotating') {
                this.angle += CONFIG.rotationSpeed;
                this.updatePos();
            } 
            else if(this.state === 'flying') {
                const prevX = this.pos.x;
                const prevY = this.pos.y;
                this.pos.x += this.velocity.x;
                this.pos.y += this.velocity.y;

                // å¢™å£ç¢°æ’æ£€æµ‹ -> è§¦å‘æºœæºœçƒå›å¼¹
                if(checkWallCollision(prevX, prevY, this.pos.x, this.pos.y)) {
                    this.triggerYoYoReturn();
                    return;
                }

                // è¾¹ç•Œæ£€æµ‹ -> è§¦å‘æºœæºœçƒå›å¼¹
                if(this.pos.x<0 || this.pos.x>canvas.width || this.pos.y<0 || this.pos.y>canvas.height) {
                    this.triggerYoYoReturn();
                    return;
                }

                // å¸é™„
                for(let d of state.dots) {
                    if(d === this.currentDot) continue;
                    if(Math.hypot(this.pos.x-d.x, this.pos.y-d.y) < CONFIG.orbitRadius+5) {
                        this.landOn(d);
                        return;
                    }
                }
            }
            else if(this.state === 'returning') {
                // æºœæºœçƒæ”¶å›é€»è¾‘ (Lerp æ’å€¼)
                const tx = this.currentDot.x;
                const ty = this.currentDot.y;
                
                this.pos.x += (tx - this.pos.x) * CONFIG.returnSpeed;
                this.pos.y += (ty - this.pos.y) * CONFIG.returnSpeed;
                
                // å¦‚æœè·ç¦»è¶³å¤Ÿè¿‘ï¼Œæ¢å¤æ—‹è½¬
                if(Math.hypot(this.pos.x-tx, this.pos.y-ty) < 10) {
                    this.state = 'rotating';
                    // é‡ç½®è§’åº¦ä¸ºå½“å‰ç›¸å¯¹äºåœ†å¿ƒçš„è§’åº¦ï¼Œé¿å…è·³å˜
                    this.angle = Math.atan2(this.pos.y-ty, this.pos.x-tx);
                }
            }
        }
        shoot() {
            if(this.state === 'rotating') {
                AudioSys.playShoot();
                this.state = 'flying';
                const angle = Math.atan2(this.pos.y-this.currentDot.y, this.pos.x-this.currentDot.x);
                this.velocity = {x: Math.cos(angle)*CONFIG.moveSpeed, y: Math.sin(angle)*CONFIG.moveSpeed};
            }
        }
        triggerYoYoReturn() {
            AudioSys.playBoing();
            state.shake = 5;
            spawnParticles(this.pos.x, this.pos.y, 0); // ç¢°æ’ç«èŠ±
            this.state = 'returning';
            // å¯ä»¥åœ¨è¿™é‡Œæ¸…é™¤ä¹‹å‰çš„è¿çº¿ï¼ˆå¦‚æœéœ€è¦æƒ©ç½šï¼‰ï¼Œæˆ–è€…ä¿ç•™
            // state.trail = []; 
        }
        landOn(newDot) {
            state.trail.push({x1:this.currentDot.x, y1:this.currentDot.y, x2:newDot.x, y2:newDot.y});
            this.state = 'rotating';
            this.currentDot = newDot;
            this.angle = Math.atan2(this.pos.y-newDot.y, this.pos.x-newDot.x);
            if(newDot.index === state.targetDotIndex) collectTarget(newDot);
        }
        draw() {
            // å¦‚æœåœ¨é£è¡Œæˆ–æ”¶å›ï¼Œç”»å‡ºæºœæºœçƒçš„ç»³å­
            if(this.state === 'flying' || this.state === 'returning') {
                ctx.beginPath();
                ctx.moveTo(this.currentDot.x, this.currentDot.y);
                ctx.lineTo(this.pos.x, this.pos.y);
                ctx.strokeStyle = CONFIG.colors.yoyoString;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // è™šçº¿çœ‹èµ·æ¥æ›´åƒç»³å­
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // ç”»çƒ
            ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 10, 0, Math.PI*2);
            ctx.fillStyle=CONFIG.colors.player; ctx.fill();
            
            // ç”»é«˜å…‰
            ctx.beginPath(); ctx.arc(this.pos.x-3, this.pos.y-3, 3, 0, Math.PI*2);
            ctx.fillStyle='#fff'; ctx.fill();
        }
    }

    // ================= è¾…åŠ©å‡½æ•° =================
    function checkWallCollision(x1, y1, x2, y2) {
        for(let w of state.walls) {
            if(getLineIntersection(x1, y1, x2, y2, w.x1, w.y1, w.x2, w.y2)) return true;
        }
        return false;
    }

    function getLineIntersection(p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y) {
        let s1_x, s1_y, s2_x, s2_y;
        s1_x = p1_x - p0_x; s1_y = p1_y - p0_y;
        s2_x = p3_x - p2_x; s2_y = p3_y - p2_y;
        let s, t, denom = -s2_x * s1_y + s1_x * s2_y;
        if (denom === 0) return false;
        s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / denom;
        t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / denom;
        return (s >= 0 && s <= 1 && t >= 0 && t <= 1);
    }

    function drawIcon(x, y, r, type) {
        ctx.save(); ctx.translate(x,y);
        if(type===0) { 
            ctx.beginPath(); ctx.fillStyle = CONFIG.colors.star;
            for(let i=0;i<5;i++){ ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*r, -Math.sin((18+i*72)/180*Math.PI)*r); ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*r*0.5, -Math.sin((54+i*72)/180*Math.PI)*r*0.5); }
            ctx.fill();
        } else if(type===1) {
            ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fillStyle=CONFIG.colors.moon; ctx.fill();
            ctx.globalCompositeOperation='destination-out'; ctx.beginPath(); ctx.arc(r*0.3,-r*0.3,r*0.8,0,Math.PI*2); ctx.fill();
            ctx.globalCompositeOperation='source-over';
        } else {
            ctx.strokeStyle=CONFIG.colors.sun; ctx.lineWidth=2;
            for(let i=0;i<8;i++){ ctx.rotate(Math.PI/4); ctx.beginPath(); ctx.moveTo(r*0.6,0); ctx.lineTo(r*1.2,0); ctx.stroke(); }
            ctx.beginPath(); ctx.arc(0,0,r*0.6,0,Math.PI*2); ctx.fillStyle=CONFIG.colors.sun; ctx.fill();
        }
        ctx.restore();
    }

    // ================= æ¸¸æˆæµç¨‹ =================
    function initLevel() {
        state.step = 0; state.trail = []; state.dots = []; state.walls = []; state.particles = [];
        
        const mX = 150, mY = 400;
        const size = Math.min(canvas.width - mX*2, canvas.height - mY*2);
        const step = size / 2;
        let idx = 0;
        
        // ç”Ÿæˆç‚¹
        for(let r=0; r<3; r++){
            for(let c=0; c<3; c++){
                state.dots.push(new Dot((canvas.width-size)/2 + c*step, (canvas.height-size)/2+50 + r*step, r, c, idx++));
            }
        }

        // ç”Ÿæˆæ–œå‘éšœç¢å¢™
        // è§„åˆ™ï¼šLevel 2 å¼€å§‹æœ‰å¢™ã€‚è¿æ¥å¯¹è§’çº¿é‚»å±…ã€‚
        const wallCount = state.level === 1 ? 0 : (state.level === 2 ? 1 : 2);
        
        let attempts = 0;
        while(state.walls.length < wallCount && attempts < 50) {
            attempts++;
            const dotA = state.dots[Math.floor(Math.random()*state.dots.length)];
            // å¯»æ‰¾å¯¹è§’çº¿é‚»å±…: è¡Œå·®1ä¸”åˆ—å·®1
            const diagonalNeighbors = state.dots.filter(d => Math.abs(d.r-dotA.r) === 1 && Math.abs(d.c-dotA.c) === 1);
            
            if(diagonalNeighbors.length > 0) {
                const dotB = diagonalNeighbors[Math.floor(Math.random()*diagonalNeighbors.length)];
                // æ£€æŸ¥é‡å¤
                if(!state.walls.some(w => (w.x1===dotA.x && w.x2===dotB.x) || (w.x1===dotB.x && w.x2===dotA.x))) {
                    state.walls.push(new Wall(dotA, dotB));
                }
            }
        }

        const startDot = state.dots[6];
        state.player = new Player(startDot);
        
        uiIcons.forEach((i,x)=>{i.className='target-icon'; i.innerText=CONFIG.shapes[x]});
        updateUI();
        spawnNextTarget();
    }

    function spawnNextTarget() {
        let cands = state.dots.filter(d => d !== state.player.currentDot);
        state.targetDotIndex = cands[Math.floor(Math.random()*cands.length)].index;
        state.dots[state.targetDotIndex].scale = 0;
    }

    function collectTarget(dot) {
        AudioSys.playCollect(state.step);
        spawnParticles(dot.x, dot.y, 2);
        state.shake = 10;
        uiIcons[state.step].classList.add('done');
        uiIcons[state.step].innerText = 'âœ”';
        uiIcons[state.step].classList.remove('active');
        
        state.step++;
        if(state.step >= 3) setTimeout(nextLevel, 1200);
        else { spawnNextTarget(); updateUI(); }
    }

    function nextLevel() { state.level++; lvlNumEl.innerText=state.level; initLevel(); }
    function updateUI() { if(state.step<3) { uiIcons[state.step].classList.add('active'); uiIcons[state.step].innerText=CONFIG.shapes[state.step]; } }

    function spawnParticles(x, y, type) {
        // type 0: wall hit, type 2: collect
        const color = type===0 ? CONFIG.colors.wall : CONFIG.colors.star;
        for(let i=0; i<10; i++) state.particles.push({x:x, y:y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:1, color:color});
    }

    // ================= ä¸»å¾ªç¯ =================
    function loop() {
        let sx=0, sy=0;
        if(state.shake>0) { sx=(Math.random()-0.5)*state.shake; sy=(Math.random()-0.5)*state.shake; state.shake*=0.9; }
        ctx.setTransform(1,0,0,1,sx,sy);
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // ç”»å¢™
        state.walls.forEach(w => w.draw());

        // ç”»è½¨è¿¹ (æˆåŠŸçš„è¿çº¿)
        if(state.trail.length>0) {
            ctx.beginPath();
            state.trail.forEach(t=>{ctx.moveTo(t.x1,t.y1); ctx.lineTo(t.x2,t.y2)});
            ctx.strokeStyle=CONFIG.colors.trail; ctx.lineWidth=4; ctx.lineCap='round'; ctx.stroke();
        }

        state.dots.forEach(d => {d.update(); d.draw()});

        if(state.player) {
            state.player.update();
            state.player.draw();
        }

        // ç²’å­
        for(let i=state.particles.length-1; i>=0; i--) {
            let p = state.particles[i];
            p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
            ctx.globalAlpha=p.life; ctx.fillStyle=p.color; 
            ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
            if(p.life<=0) state.particles.splice(i,1);
        }
        ctx.globalAlpha=1;

        requestAnimationFrame(loop);
    }

    window.addEventListener('mousedown', (e)=>{ e.preventDefault(); AudioSys.init(); state.player.shoot(); });
    window.addEventListener('touchstart', (e)=>{ e.preventDefault(); AudioSys.init(); state.player.shoot(); }, {passive:false});

    initLevel();
    loop();

</script>
</body>
</html>